package org.example;

import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.json.JSONArray;
import org.json.JSONObject;

import java.io.FileInputStream;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

public class ExcelToJson {
    private Workbook workbook;
    private  Sheet sheet;
    private JSONObject jsonObject;

    public JSONObject getJsonObject() {
        return jsonObject;
    }

    public ExcelToJson(String filePath, String sheetname) throws IOException {
        this.workbook = new XSSFWorkbook(new FileInputStream(filePath));
        this.sheet = workbook.getSheet(sheetname);
        this.jsonObject = new JSONObject();
    }

    public static void main(String[] args) {


        try {
            String file = "D:\\UserData\\Downloads\\MOCK_DATA.xlsx";

            ExcelToJson excelToJson = new ExcelToJson(file, "prueba");
            excelToJson.addSimpleElements("TestData");
            excelToJson.processArray("ABC", new String[]{"SubArray1a", "SubArray2a", "SubArra3"});
            excelToJson.processArray("heidy", null);
            excelToJson.processArray("Tesr", new String[]{"prueba2", "prueba1"});

            JSONArray array = new JSONArray();
            array.put(excelToJson.jsonObject);

            System.out.println(array.toString(4));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void processArray(String mainKeyName, String[] subarrays) {
        Map<String, String> subArrayMappings = new HashMap<>();
        if (subarrays != null) {
            for (String subarray : subarrays) {
                subArrayMappings.put(subarray, subarray);
            }
        }
        try {
            JSONObject mainObject = processExcelFile(mainKeyName, subArrayMappings);
            if (!mainObject.isEmpty()) {
                jsonObject.put(mainKeyName, mainObject);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }


    private JSONObject processExcelFile(String mainKeyName, Map<String, String> subArrayMappings) throws IOException {
        int[] rowRange = findRowRangeForMainKey(sheet, mainKeyName);
        System.out.println("Row Range: " + rowRange[0] + " - " + rowRange[1]);

        return processExcelData(sheet, rowRange[0], rowRange[1], mainKeyName, subArrayMappings);
    }


    private  boolean isPartOfArray(String key, Map<String, String> subArrayMappings) {
        for (Map.Entry<String, String> entry : subArrayMappings.entrySet()) {
            if (key != null && key.startsWith(entry.getKey() + ".")) {
                return true;
            }
        }
        return false;
    }

    private  int[] findRowRangeForMainKey(Sheet sheet, String mainKeyName) {
        int startRow = findCellValue(sheet, mainKeyName);
        int endRow = findCellValue(sheet, "END-" + mainKeyName) + 1;

        if (startRow == -1) startRow = 0;
        if (endRow == -1) endRow = sheet.getLastRowNum();

        return new int[]{startRow, endRow};
    }

    private  int findCellValue(Sheet sheet, String searchString) {
        for (Row row : sheet) {
            for (Cell cell : row) {
                if (cell.getCellType() == CellType.STRING && cell.getStringCellValue().equals(searchString)) {
                    return row.getRowNum() - 1;
                }
            }
        }
        return -1;
    }

    private  JSONObject processExcelData(Sheet sheet, int startRow, int endRow, String mainKeyName, Map<String, String> subArrayMappings) {
        return processMainKey(sheet, startRow, endRow, mainKeyName, subArrayMappings);
    }



private JSONObject processMainKey(Sheet sheet, int startRow, int endRow, String mainKeyName, Map<String, String> subArrayMappings) {
    JSONObject mainObject = new JSONObject();
    String currentMainKey = null;
    boolean mainKeyAdded = false;

    for (int i = startRow; i <= endRow; i++) {
        Row row = sheet.getRow(i);
        if (row == null) continue;

        JSONObject sectionObject = new JSONObject();
        Map<String, JSONObject> subObjects = new HashMap<>();
        Map<String, JSONArray> subArrays = new HashMap<>();
        boolean isRowEmpty = true;

        for (Cell cell : row) {
            String key = getHeaderName(sheet, cell.getColumnIndex(), startRow);
            Object value = getCellValue(cell);

            if (isMainKeyRow(key, value, mainKeyName)) {
                if (!mainKeyAdded) {
                    currentMainKey = mainKeyName;
                    mainKeyAdded = true;
                }
                continue;
            }

            if (isEndRow(value, currentMainKey)) {
                currentMainKey = null;
                mainKeyAdded = false;
                break;
            }

            if (value != null && !value.toString().isBlank()) {
                isRowEmpty = false;
            }

            if (key != null) {
                if (isPartOfArray(key, subArrayMappings)) {
                    processSubArrays(subArrayMappings, key, value, subObjects, subArrays);
                } else {
                    sectionObject.put(key, value);
                }
            }
        }

        if (!isRowEmpty && currentMainKey != null) {
            addSubObjectsToSectionObject(subObjects, sectionObject);
            addSubArraysToSectionObject(subArrays, sectionObject);
            jsonObject.put(currentMainKey, sectionObject);
        }
    }

    return mainObject;
}
    private  void addSubObjectsToSectionObject(Map<String, JSONObject> subObjects, JSONObject sectionObject) {
        for (Map.Entry<String, JSONObject> subObjectEntry : subObjects.entrySet()) {
            sectionObject.put(subObjectEntry.getKey(), subObjectEntry.getValue());
        }
    }

    private  boolean isMainKeyRow(String key, Object value, String mainKeyName) {
        return key != null && key.startsWith("MainKey-") && value != null && value.toString().equals(mainKeyName);
    }

    private  boolean isEndRow(Object value, String currentMainKey) {
        return value != null && currentMainKey != null && value.toString().equals("END-" + currentMainKey);
    }


    private void processSubArrays(Map<String, String> subArrayMappings, String key, Object value, Map<String, JSONObject> subObjects, Map<String, JSONArray> subArrays) {
        for (String subArrayKey : subArrayMappings.keySet()) {
            if (key != null && key.startsWith(subArrayKey)) {
                String dynamicArrayName = subArrayMappings.get(subArrayKey);
                JSONObject subObject = subObjects.computeIfAbsent(dynamicArrayName, k -> new JSONObject());

                String subKey = key.replace(subArrayKey + ".", "");

                // Verificar si el subKey contiene un punto, lo cual indica que debe ser parte de un array
                if (subKey.contains(".")) {
                    // Dividir la clave en base al punto
                    String[] parts = subKey.split("\\.", 2);
                    String arrayName = parts[0];
                    String itemKey = parts[1];

                    JSONArray array = subArrays.computeIfAbsent(arrayName, k -> new JSONArray());
                    JSONObject arrayItem = new JSONObject();

                    // Verificar si ya existe un objeto en el array
                    if (array.length() > 0) {
                        // Obtener el último objeto del array
                        arrayItem = array.getJSONObject(array.length() - 1);
                    }

                    // Agregar el valor al objeto del array
                    arrayItem.put(itemKey, value);

                    // Si el objeto es nuevo o tiene más claves, agregarlo al array
                    if (array.length() == 0 || arrayItem.length() > 0) {
                        if (array.length() == 0 || !arrayItem.has(itemKey)) {
                            array.put(arrayItem);
                        }
                    }

                    subArrays.put(arrayName, array);

                } else {
                    // Manejo de los elementos que no son parte de un array
                    if (subObject.has(subKey)) {
                        Object existingValue = subObject.get(subKey);
                        if (existingValue instanceof JSONArray) {
                            ((JSONArray) existingValue).put(value);
                        } else {
                            JSONArray newArray = new JSONArray();
                            newArray.put(existingValue);
                            newArray.put(value);
                            subObject.put(subKey, newArray);
                        }
                    } else {
                        subObject.put(subKey, value);
                    }

                    subObjects.put(dynamicArrayName, subObject);
                }
                return;
            }
        }
    }


    private static void addSubArraysToSectionObject(Map<String, JSONArray> subArrays, JSONObject sectionObject) {
        for (Map.Entry<String, JSONArray> subArrayEntry : subArrays.entrySet()) {
            sectionObject.put(subArrayEntry.getKey(), subArrayEntry.getValue());
        }
    }

    private static String getHeaderName(Sheet sheet, int columnIndex, int headerRowNumber) {
        Row headerRow = sheet.getRow(headerRowNumber);
        if (headerRow != null) {
            Cell headerCell = headerRow.getCell(columnIndex);
            if (headerCell != null) {
                return headerCell.getStringCellValue();
            }
        }
        return null;
    }

    private void addSimpleElements(String startRowName) {
        int startRowIndex = -1;
        int headerRowIndex = -1;

        for (int i = 0; i <= sheet.getLastRowNum(); i++) {
            Row row = sheet.getRow(i);
            if (row != null) {
                for (Cell cell : row) {
                    if (cell.getCellType() == CellType.STRING && cell.getStringCellValue().equalsIgnoreCase(startRowName)) {
                        startRowIndex = i;
                        headerRowIndex = i + 1;
                        break;
                    }
                }
                if (startRowIndex != -1) {
                    break;
                }
            }
        }

        if (startRowIndex != -1 && headerRowIndex <= sheet.getLastRowNum()) {
            Row headerRow = sheet.getRow(headerRowIndex);
            Row dataRow = sheet.getRow(headerRowIndex + 1);

            if (headerRow != null && dataRow != null) {
                for (int i = 0; i < headerRow.getLastCellNum(); i++) {
                    String header = headerRow.getCell(i).getStringCellValue();
                    Cell dataCell = dataRow.getCell(i);
                    Object value = getCellValue(dataCell);
                    jsonObject.put(header, value);
                }
            }
        }
    }


    private static Object getCellValue(Cell cell) {
        if (cell == null) {
            return null;
        }
        switch (cell.getCellType()) {
            case STRING:
                return cell.getStringCellValue().trim();
            case NUMERIC:
                if (DateUtil.isCellDateFormatted(cell)) {
                    return cell.getDateCellValue();
                } else {
                    return cell.getNumericCellValue();
                }
            case BOOLEAN:
                return cell.getBooleanCellValue();
            case FORMULA:
                return cell.getCellFormula();
            case BLANK:
                return null;
            default:
                return cell.toString().trim();
        }
    }}
---
    private void processSubArrays(Map<String, String> subArrayMappings, String key, Object value, Map<String, JSONObject> subObjects, Map<String, JSONArray> subArrays) {
        for (String subArrayKey : subArrayMappings.keySet()) {
            if (key != null && key.startsWith(subArrayKey)) {
                String dynamicArrayName = subArrayMappings.get(subArrayKey);
                JSONArray array = subArrays.computeIfAbsent(dynamicArrayName, k -> new JSONArray());

                String subKey = key.replace(subArrayKey + ".", "");

                if (subKey.contains(".")) {
                    // Divide la clave en base al punto
                    String[] parts = subKey.split("\\.", 2); // Dividir en dos partes

                    if (parts.length == 2) {
                        String itemKey = parts[0];
                        String subItemKey = parts[1];

                        // Encuentra o crea un objeto en el array para el itemKey
                        JSONObject arrayItem = array.length() > 0 ? array.getJSONObject(array.length() - 1) : new JSONObject();
                        if (!arrayItem.has(itemKey)) {
                            arrayItem.put(itemKey, new JSONObject());
                        }

                        // Agrega el valor al objeto del array
                        JSONObject itemObject = arrayItem.getJSONObject(itemKey);
                        itemObject.put(subItemKey, value);

                        if (array.length() == 0) {
                            array.put(arrayItem);
                        } else {
                            array.put(arrayItem);
                        }
                    }
                } else {
                    // Si solo hay una propiedad, agrégala como un objeto completo
                    if (array.length() == 0) {
                        JSONObject newItem = new JSONObject();
                        newItem.put(subKey, value);
                        array.put(newItem);
                    } else {
                        JSONObject lastItem = array.getJSONObject(array.length() - 1);
                        lastItem.put(subKey, value);
                    }

                    subArrays.put(dynamicArrayName, array);
                }
                return;
            }
        }
    }


